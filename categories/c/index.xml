<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C on ~klyr</title>
    <link>https://klyr.github.io/categories/c/</link>
    <description>Recent content in C on ~klyr</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 25 Apr 2018 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://klyr.github.io/categories/c/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Playing with eBPF (extended BPF)</title>
      <link>https://klyr.github.io/posts/ebpf/</link>
      <pubDate>Wed, 25 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://klyr.github.io/posts/ebpf/</guid>
      <description>Introduction eBPF stands for extended Berkeley Packet Filter, but can do more than just filter packets.
The idea is the same as when you use the tcpdump command:
$ tcpdump ip host helios and port 80 the ip host helios and port 80 filter/program is compiled and run in a virtual machine.
With eBPF, you program in C (a restricted version of it), you compile it to the target VM then load this code inside the kernel and run it inside the kernel.</description>
    </item>
    
    <item>
      <title>Updating IP routes programmatically</title>
      <link>https://klyr.github.io/posts/updating_ip_routes_in_c/</link>
      <pubDate>Mon, 10 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://klyr.github.io/posts/updating_ip_routes_in_c/</guid>
      <description>ioctl(2) is a special system call used when no other system call can handle a specific I/O operation. For exemple, the generic write(2) syscall is used for writing to a specified file descriptor but there is neither syscall to open the CD-tray nor syscall to manage routing tables: ioctl is here as a fit-all syscall.
From the man page:
NAME ioctl - control device SYNOPSIS #include &amp;lt;sys/ioctl.h&amp;gt; int ioctl(int d, int request, void *args); DESCRIPTION The ioctl() function manipulates the underlying device parameters of special files.</description>
    </item>
    
    <item>
      <title>Display backtrace when a program segfaults</title>
      <link>https://klyr.github.io/posts/gnu_backtrace_extension/</link>
      <pubDate>Mon, 03 Dec 2012 00:00:00 +0000</pubDate>
      
      <guid>https://klyr.github.io/posts/gnu_backtrace_extension/</guid>
      <description>Display backtrace when a program segfaults When an application crashes, with a segfault for example it can be usefull have debugging help like a stacktrace of function calls.
This can be achieved by trapping the SIGSEGV unix signal and by using the backtrace(3) and backtrace_symbols(3) GNU extensions functions.
Intercept SIGSEGV signal (and others) This is done via the traditional use of sigaction:
#include &amp;lt;signal.h&amp;gt; struct sigaction handler; sigemptyset(&amp;amp;handler.sa_mask); handler.sa_flags = SA_NODEFER | SA_RESETHAND; handler.</description>
    </item>
    
    <item>
      <title>C pointers &amp; Ksplice challenge</title>
      <link>https://klyr.github.io/posts/c_pointers_ksplice_challenge/</link>
      <pubDate>Wed, 19 Oct 2011 00:00:00 +0000</pubDate>
      
      <guid>https://klyr.github.io/posts/c_pointers_ksplice_challenge/</guid>
      <description> C pointers &amp;amp; Ksplice challenge The Ksplice Pointer Challenge.
#include &amp;lt;stdio.h&amp;gt; int main() { int x[5]; printf(&amp;#34;%p\n&amp;#34;, x); printf(&amp;#34;%p\n&amp;#34;, x+1); printf(&amp;#34;%p\n&amp;#34;, &amp;amp;x); printf(&amp;#34;%p\n&amp;#34;, &amp;amp;x+1); return 0; } On a 64bits architecture:
0x7fffe4a594d0 0x7fffe4a594d4 0x7fffe4a594d0 0x7fffe4a594e4</description>
    </item>
    
  </channel>
</rss>