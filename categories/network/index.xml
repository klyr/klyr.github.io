<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>network on ~klyr</title>
    <link>https://klyr.github.io/categories/network/</link>
    <description>Recent content in network on ~klyr</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 02 Apr 2020 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://klyr.github.io/categories/network/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Playing with the P4 language</title>
      <link>https://klyr.github.io/posts/playing_with_p4/</link>
      <pubDate>Thu, 02 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://klyr.github.io/posts/playing_with_p4/</guid>
      <description>Introduction P4 is a domain-specific compiled programming language for network data forwarding. It does not know anything about already existing protocols: it doesn&amp;rsquo;t know IP, nor TCP.
A P4 program is compiled to something that is understandable by the P4 aware device. Such device can be a really hardware switch, a software switch, a FPGA.
In this article we will try to use a software switch. More precisely, the uBPF backend.</description>
    </item>
    
    <item>
      <title>Playing with uBPF</title>
      <link>https://klyr.github.io/posts/playing_with_ubpf/</link>
      <pubDate>Thu, 02 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://klyr.github.io/posts/playing_with_ubpf/</guid>
      <description>Introduction uBPF is a user-land implementation of the eBPF VM.
Installation $ git clone https://github.com/iovisor/ubpf.git $ cd ubpf $ make -C vm This compiles the ubpf library (libubpf.a) and a test program to use this library.
Run a simple eBPF program with uBPF static int idouble(int a) { return (a * 2); } int bpf_prog(void *ctx) { int a = 1; a = idouble(a); return (a); } Compile to a BPF binary, which is executable by the kernel eBPF VM, or, in our specific case, the user-land uBFP VM.</description>
    </item>
    
    <item>
      <title>Playing with eBPF (extended BPF)</title>
      <link>https://klyr.github.io/posts/ebpf/</link>
      <pubDate>Wed, 25 Apr 2018 00:00:00 +0000</pubDate>
      
      <guid>https://klyr.github.io/posts/ebpf/</guid>
      <description>Let&amp;rsquo;s play with eBPF in order to find what is slowing down my computer</description>
    </item>
    
    <item>
      <title>Playing with the Erlang Linc Switch</title>
      <link>https://klyr.github.io/posts/playing_with_linc_switch/</link>
      <pubDate>Fri, 19 Dec 2014 00:00:00 +0000</pubDate>
      
      <guid>https://klyr.github.io/posts/playing_with_linc_switch/</guid>
      <description>Introduction Linc is a software switch in Erlang, which support Openflow 1.4.
Here we will try to install it and make it run in a simple scenario. Later we will try to use it with an openflow compatible Controller (maybe Opendaylight or FlowER).
Installation $ git clone https://github.com/FlowForwarding/LINC-Switch.git $ sudo apt-get install libpcap0.8-dev $ cd LINC-Switch $ cp rel/files/sys.config.orig rel/files/sys.config $ make Note that at some point during installation, root privileges are required to use the setcap utility.</description>
    </item>
    
    <item>
      <title>Ip routing based on destination port</title>
      <link>https://klyr.github.io/posts/ip_route_based_on_port/</link>
      <pubDate>Wed, 18 Apr 2012 00:00:00 +0000</pubDate>
      
      <guid>https://klyr.github.io/posts/ip_route_based_on_port/</guid>
      <description>Route packets based on destination port</description>
    </item>
    
    <item>
      <title>Using a free CDN, Cloudflare</title>
      <link>https://klyr.github.io/posts/using_a_free_cdn/</link>
      <pubDate>Mon, 08 Aug 2011 00:00:00 +0000</pubDate>
      
      <guid>https://klyr.github.io/posts/using_a_free_cdn/</guid>
      <description>CDN: Content delivery network A CDN act as a cache for static ressources of your web server. One famous CDN is Akamai but is quite expensive.
CDN architecture is quite complex with a set of multiple proxies located in multiple datacenters around the world. The goal is to reduce the distance to the minimum between the served ressource and the user asking for the ressource.
A CDN not only saves the bandwith and load of your server but also global Internet peers involved between the client and the server.</description>
    </item>
    
  </channel>
</rss>